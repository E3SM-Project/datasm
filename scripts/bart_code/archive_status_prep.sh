#!/bin/bash

# Usage:  archive_status_prep.sh archive_map(all or part) [trust_match]
#
# For the entire archive, use /p/user_pub/e3sm/archive/.cfg/Archive_Map
# For a subset, create a file with selected lines, and give its full path
# format:  Campaign,Model,Experiment,Ensemble,DatasetType,ArchivePath,DatatypeExtractionPattern,Notes
# Full Archive Map file:  /p/user_pub/e3sm/archive/.cfg/Archive_Map
#
# if "trust_match" is absent, and the canonical part of the first/last filenames (used to extract sim-dates)
# do NOT match, The output will not calculate "years" for that dataset, and the output will contain lines
# NO_MATCH: <filenames> in order to allow manual inspection.  If the inspection indicates that the files
# belong to different datasets, or are otherwise inappropriately paired, then there are errors in the 
# Archive_Map that need to be addressed (the file-matching patterns are insufficiently specific.)
# If the inspection indicates that the match failures are due to "harmless" differences (different
# machine-names, or different generation-dates due to restarts) then re-run this script with
# "trust_match" (as indicated in "Usage" above) to skip the first/last filename check.


# PURPOSE:  From input Archive Map
#  campaign, model, experiment, ens, title, archive_path, tar_extract_pattern
#
#  Produce a listing
# 	model, resolution, ens, Title, status, grid, years, filecount, datasetID, datasetFirstFile, DatasetPubPath,Notes, titleExpanded, misc
#
#  THe following table outlines the source of each item
#
#	model			Direct from Archive Map
#	resolution		use "$default_res" below
#	ensemble		Direct from Archive Map
#	title			extract from Archive Map "DatasetType"
#	status			[HC] "arch"
#	grid			[HC] "native"
#	years			[HC] ""
#	filecount		Generated by inspection
#	datasetID		Constructed from all of these values and sources
#	firstFile		Generated by inspection
#	pubPath			Constructed from datasetID
#	notes			[HC] "model-output"
#	titleExpanded		reit title
#	misc			[HC] ""

#  A datasetID needs
#	E3SM.<model>.<experiment>.<resolution>.<realm>.<grid>.model_output.<freq>.<ens>

archive_map_file=$1

trust_match=0
if [ $# -eq 2 ]; then
	if [ $2 == "trust_match" ]; then
		trust_match=1
	fi
fi

simdate_locator=/p/user_pub/e3sm/archive/.cfg/Filename_SimDate_Locator

The_Holodeck=/p/user_pub/e3sm/bartoletti1/Pub_Status/ArchiveAssess/Holodeck


zstash_version=`zstash version`
if [ $zstash_version != "v0.4.1" ]; then
	echo "ABORTING:  zstash version is not 0.4.1 or is unavailable"
	exit 1
fi

default_res="1deg_atm_60-30km_ocean"

startTime=`date +%s`

IFS=$'\n'

cd $The_Holodeck

for aline in `cat $archive_map_file`; do

	model=`echo $aline | cut -f2 -d,`
	experiment=`echo $aline | cut -f3 -d,`
	resolution=$default_res
	ens=`echo $aline | cut -f4 -d,`
	title=`echo $aline | cut -f5 -d, | tr _ ' '` # may need tr _ ' '
	realmcode=`echo $title | cut -f1 -d' '`
	freq=`echo $title | cut -f3 -d' '`
	pstatus="arch"
	grid="native"
	years=""
	notes="model-output"
	otype=$notes
	misc=""

	# translate realmcode to realm
	if [ $realmcode == "atm" ]; then
		realm="atmos"
	elif [ $realmcode == "lnd" ]; then
		realm="land"
	elif [ $realmcode == "ocn" ]; then
		realm="ocean"
	elif [ $realmcode == "river" ]; then
		realm="river"
	elif [ $realmcode == "sea-ice" ]; then
		realm="sea-ice"
	else realm="UNK_$realmcode"
	fi

	datasetID="E3SM.$model.$experiment.$resolution.$realm.$grid.$otype.$freq.$ens"
	pubPath=`echo $datasetID | tr . /`

	# echo "DEBUG: dsID=$datasetID"
	# continue

	# still need to formulate filecount, firstFile, (titleExpanded)

	apath=`echo $aline | cut -f6 -d,`
	if [ $apath == "NAV" ]; then
		continue
	fi

	basetag=`echo $aline | cut -f1-5 -d,`
	pattern=`echo $aline | cut -f7 -d,`

	# echo "DEBUG:  Basetag=$basetag"

	rm -rf $The_Holodeck/*
	mkdir $The_Holodeck/zstash

	ln -s $apath/index.db $The_Holodeck/zstash/index.db
	
	zstash ls --hpss=none $pattern > /tmp/zstash_manifest

	filecount=`cat /tmp/zstash_manifest | wc -l`

	init_file=`cat /tmp/zstash_manifest | head -1`
	last_file=`cat /tmp/zstash_manifest | tail -1`

	# trim tar-path from first and last
	filebase1=`echo $init_file | rev | cut -f1 -d/ | rev`
	filebase2=`echo $last_file | rev | cut -f1 -d/ | rev`

	# echo "DEBUG: filebase1=$filebase1"
	# echo "DEBUG: filebase2=$filebase2"

	simdfield=`grep $basetag: $simdate_locator | cut -f2 -d:`
	prevfield=$((simdfield - 1))
	
	sim_date1=`echo $filebase1 | cut -f$simdfield -d.`
	filetest1=`echo $filebase1 | cut -f1-$prevfield -d.`
	sim_date2=`echo $filebase2 | cut -f$simdfield -d.`
	filetest2=`echo $filebase2 | cut -f1-$prevfield -d.`

	# echo "DEBUG: simdfield=$simdfield"
	# echo "DEBUG: sim_date1=$sim_date1"
	# echo "DEBUG: sim_date2=$sim_date2"
	# last part eliminates variable leading run_dates
	filecore1=`echo $filetest1 | cut -f2- -d.`
	filecore2=`echo $filetest2 | cut -f2- -d.`

	if [ $trust_match -eq 0 ]; then

		if [ $filecore1 != $filecore2 ]; then
			# echo "$basetag,NO_MATCH,$filecount,$init_file,$last_file"
			echo "NO_MATCH:                  $filecore1"
			echo "NO_MATCH:                  $filecore2"
			years="NAV"
			echo "$model,$resolution,$ens,$title,$pstatus,$grid,$years,$filecount,$datasetID,$filebase1,$pubPath,$otype,$title,$misc"
			continue;
		fi
	fi
			
	y1=`echo $sim_date1 | cut -c1-4`
	y2=`echo $sim_date2 | cut -c1-4`
	m2=`echo $sim_date2 | cut -c6-7`
	y1=$((10#$y1))
	y2=$((10#$y2))
	yspan=$((y2 - y1 + 1))
	if [ $m2 == "01" ]; then
		yspan=$((y2 - y1))
	fi
	# echo "$basetag,MATCHED,$filecount,$filetest1,$sim_date1,$sim_date2,$yspan"
	years=$yspan

	# 	model, resolution, ens, Title, status, grid, years, filecount, datasetID, datasetFirstFile, DatasetPubPath,Notes, titleExpanded, misc
	echo "$model,$resolution,$ens,$title,$pstatus,$grid,$years,$filecount,$datasetID,$filebase1,$pubPath,$otype,$title,$misc"

done

finalTime=`date +%s`

et=$(($finalTime-$startTime))

echo "Done.  ET = $et"


exit

